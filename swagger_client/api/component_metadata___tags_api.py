# coding: utf-8

"""
    Adobe Analytics APIs

    The endpoints described here are routed through Adobe.io.          In order to use these endpoints you must create an oAuth client that is          subscribed to access the Adobe Analytics Reporting API.  # noqa: E501

    OpenAPI spec version: v1 - Build: 2019-10-03_20:32:29.323
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ComponentMetadataTagsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_tag(self, id, **kwargs):  # noqa: E501
        """Removes the tagId and all associations from that tag to any components  # noqa: E501

        Delete by tagId. Will un-tag any/all components that were associated with the passed tagId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The tagId to be deleted (required)
        :return: list[dict(str, object)]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tag_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tag_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_tag_with_http_info(self, id, **kwargs):  # noqa: E501
        """Removes the tagId and all associations from that tag to any components  # noqa: E501

        Delete by tagId. Will un-tag any/all components that were associated with the passed tagId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The tagId to be deleted (required)
        :return: list[dict(str, object)]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[dict(str, object)]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tag_items(self, component_ids, component_type, **kwargs):  # noqa: E501
        """Disassociates all tags from the given components  # noqa: E501

        Removes all tags from the passed componentIds. Note that currently this is done in a single DB query, so there is a single combined response for the entire operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag_items(component_ids, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str component_ids: Comma-separated list of componentIds to operate on. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[dict(str, object)]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tag_items_with_http_info(component_ids, component_type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tag_items_with_http_info(component_ids, component_type, **kwargs)  # noqa: E501
            return data

    def delete_tag_items_with_http_info(self, component_ids, component_type, **kwargs):  # noqa: E501
        """Disassociates all tags from the given components  # noqa: E501

        Removes all tags from the passed componentIds. Note that currently this is done in a single DB query, so there is a single combined response for the entire operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag_items_with_http_info(component_ids, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str component_ids: Comma-separated list of componentIds to operate on. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[dict(str, object)]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['component_ids', 'component_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tag_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'component_ids' is set
        if ('component_ids' not in params or
                params['component_ids'] is None):
            raise ValueError("Missing the required parameter `component_ids` when calling `delete_tag_items`")  # noqa: E501
        # verify the required parameter 'component_type' is set
        if ('component_type' not in params or
                params['component_type'] is None):
            raise ValueError("Missing the required parameter `component_type` when calling `delete_tag_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'component_ids' in params:
            query_params.append(('componentIds', params['component_ids']))  # noqa: E501
        if 'component_type' in params:
            query_params.append(('componentType', params['component_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[dict(str, object)]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_all_for_company(self, **kwargs):  # noqa: E501
        """Returns a list of tags for the current user's company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_for_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_all_for_company_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_all_for_company_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_all_for_company_with_http_info(self, **kwargs):  # noqa: E501
        """Returns a list of tags for the current user's company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_for_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_all_for_company" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Tag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_components_by_tag_name(self, tag_names, component_type, **kwargs):  # noqa: E501
        """Retrieves component ids associated with the given tag names  # noqa: E501

        Given a comma separated list of tag names, return component ids associated with them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_components_by_tag_name(tag_names, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_names: Comma separated list of tag names. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_components_by_tag_name_with_http_info(tag_names, component_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_components_by_tag_name_with_http_info(tag_names, component_type, **kwargs)  # noqa: E501
            return data

    def get_components_by_tag_name_with_http_info(self, tag_names, component_type, **kwargs):  # noqa: E501
        """Retrieves component ids associated with the given tag names  # noqa: E501

        Given a comma separated list of tag names, return component ids associated with them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_components_by_tag_name_with_http_info(tag_names, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_names: Comma separated list of tag names. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag_names', 'component_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_components_by_tag_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag_names' is set
        if ('tag_names' not in params or
                params['tag_names'] is None):
            raise ValueError("Missing the required parameter `tag_names` when calling `get_components_by_tag_name`")  # noqa: E501
        # verify the required parameter 'component_type' is set
        if ('component_type' not in params or
                params['component_type'] is None):
            raise ValueError("Missing the required parameter `component_type` when calling `get_components_by_tag_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'tag_names' in params:
            query_params.append(('tagNames', params['tag_names']))  # noqa: E501
        if 'component_type' in params:
            query_params.append(('componentType', params['component_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/tagnames', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_by_id(self, id, **kwargs):  # noqa: E501
        """Retrieves an tag by its id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Tag ID to be retrieved (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tag_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tag_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_tag_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieves an tag by its id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Tag ID to be retrieved (required)
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_tag_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_list_by_component_id_and_component_type(self, component_id, component_type, **kwargs):  # noqa: E501
        """Retrieves a tags for a given component by componentId and componentType  # noqa: E501

        Given a componentId, return all tags associated with that component  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_list_by_component_id_and_component_type(component_id, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str component_id: The componentId to operate on. Currently this is just the segmentId. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tag_list_by_component_id_and_component_type_with_http_info(component_id, component_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tag_list_by_component_id_and_component_type_with_http_info(component_id, component_type, **kwargs)  # noqa: E501
            return data

    def get_tag_list_by_component_id_and_component_type_with_http_info(self, component_id, component_type, **kwargs):  # noqa: E501
        """Retrieves a tags for a given component by componentId and componentType  # noqa: E501

        Given a componentId, return all tags associated with that component  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_list_by_component_id_and_component_type_with_http_info(component_id, component_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str component_id: The componentId to operate on. Currently this is just the segmentId. (required)
        :param str component_type: The component type to operate on. (required)
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['component_id', 'component_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_list_by_component_id_and_component_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'component_id' is set
        if ('component_id' not in params or
                params['component_id'] is None):
            raise ValueError("Missing the required parameter `component_id` when calling `get_tag_list_by_component_id_and_component_type`")  # noqa: E501
        # verify the required parameter 'component_type' is set
        if ('component_type' not in params or
                params['component_type'] is None):
            raise ValueError("Missing the required parameter `component_type` when calling `get_tag_list_by_component_id_and_component_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'component_id' in params:
            query_params.append(('componentId', params['component_id']))  # noqa: E501
        if 'component_type' in params:
            query_params.append(('componentType', params['component_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Tag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_tag_component_list(self, **kwargs):  # noqa: E501
        """Tag a component with one or many tags at once. WARNING: Authoritative; deletes/overwrites all pre-existing associations  # noqa: E501

        This endpoint allows many tags at once to be created/deleted. Any tags passed to this endpoint will become the *only* tags for that componentId (all other tags will be removed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_tag_component_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[TaggedComponent] body: JSON-formatted object containing key-value pairs that conform to the schema
        :return: list[TaggedComponent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_tag_component_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_tag_component_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_tag_component_list_with_http_info(self, **kwargs):  # noqa: E501
        """Tag a component with one or many tags at once. WARNING: Authoritative; deletes/overwrites all pre-existing associations  # noqa: E501

        This endpoint allows many tags at once to be created/deleted. Any tags passed to this endpoint will become the *only* tags for that componentId (all other tags will be removed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_tag_component_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[TaggedComponent] body: JSON-formatted object containing key-value pairs that conform to the schema
        :return: list[TaggedComponent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_tag_component_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/tagitems', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaggedComponent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_tag_list(self, **kwargs):  # noqa: E501
        """Saves the given tag(s) for the current user's company  # noqa: E501

        Allows creation of a new tag and applies that new tag to the passed component  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_tag_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Tag] body: JSON-formatted array of Tag objects containing key-value pairs
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_tag_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_tag_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_tag_list_with_http_info(self, **kwargs):  # noqa: E501
        """Saves the given tag(s) for the current user's company  # noqa: E501

        Allows creation of a new tag and applies that new tag to the passed component  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_tag_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Tag] body: JSON-formatted array of Tag objects containing key-value pairs
        :return: list[Tag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_tag_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Tag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_component_tags2(self, **kwargs):  # noqa: E501
        """search for tags for several components at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_component_tags2(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComponentSearch body: items to search for
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :return: TaggedComponent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_component_tags2_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_component_tags2_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_component_tags2_with_http_info(self, **kwargs):  # noqa: E501
        """search for tags for several components at once  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_component_tags2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ComponentSearch body: items to search for
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :return: TaggedComponent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'limit', 'page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_component_tags2" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/componentmetadata/tags/component/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaggedComponent',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
