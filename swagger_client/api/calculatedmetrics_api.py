# coding: utf-8

"""
    Adobe Analytics APIs

    The endpoints described here are routed through Adobe.io.          In order to use these endpoints you must create an oAuth client that is          subscribed to access the Adobe Analytics Reporting API.  # noqa: E501

    OpenAPI spec version: v1 - Build: 2019-10-03_20:32:29.323
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class CalculatedmetricsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def calculatedmetrics_create_calculated_metric(self, **kwargs):  # noqa: E501
        """Create a new Calculated Metric  # noqa: E501

        Creates a new calculated metric. The following attributes are available when creating a calculated metric:  IMPORTANT: Required Fields: name, definition, rsid  Optional fields: description  Example definition for use in testing API below (\"Visits per visitor\"):  ```json  \"definition\": {        \"formula\": {          \"func\": \"divide\",          \"col1\": {            \"func\": \"metric\",            \"name\": \"metrics/visits\",            \"description\": \"Visits\"          },          \"col2\": {            \"func\": \"metric\",            \"name\": \"metrics/visitors\",            \"description\": \"Unique Visitors\"          }        },        \"func\": \"calc-metric\",        \"version\": [          1,          0,          0        ]      } ```  A calculated metric response will always include these default items:* id, name, description, rsid, owner*   Other attributes can be optionally requested through the 'expansion' field as defined/documented in the GET endpoints (see GET \"/calculatedmetrics\" or GET \"/calculatedmetrics/{id}\" for more documentation).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_create_calculated_metric(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs for calculated metric creation.
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_create_calculated_metric_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_create_calculated_metric_with_http_info(**kwargs)  # noqa: E501
            return data

    def calculatedmetrics_create_calculated_metric_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new Calculated Metric  # noqa: E501

        Creates a new calculated metric. The following attributes are available when creating a calculated metric:  IMPORTANT: Required Fields: name, definition, rsid  Optional fields: description  Example definition for use in testing API below (\"Visits per visitor\"):  ```json  \"definition\": {        \"formula\": {          \"func\": \"divide\",          \"col1\": {            \"func\": \"metric\",            \"name\": \"metrics/visits\",            \"description\": \"Visits\"          },          \"col2\": {            \"func\": \"metric\",            \"name\": \"metrics/visitors\",            \"description\": \"Unique Visitors\"          }        },        \"func\": \"calc-metric\",        \"version\": [          1,          0,          0        ]      } ```  A calculated metric response will always include these default items:* id, name, description, rsid, owner*   Other attributes can be optionally requested through the 'expansion' field as defined/documented in the GET endpoints (see GET \"/calculatedmetrics\" or GET \"/calculatedmetrics/{id}\" for more documentation).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_create_calculated_metric_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs for calculated metric creation.
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'expansion']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_create_calculated_metric" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'expansion' in params:
            query_params.append(('expansion', params['expansion']))  # noqa: E501
            collection_formats['expansion'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalyticsCalculatedMetric',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculatedmetrics_delete_calculated_metric(self, id, **kwargs):  # noqa: E501
        """Deletion of Calculated Metrics by Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_delete_calculated_metric(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The calculated metric ID to be deleted (required)
        :param str locale: Locale
        :return: DeleteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_delete_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_delete_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def calculatedmetrics_delete_calculated_metric_with_http_info(self, id, **kwargs):  # noqa: E501
        """Deletion of Calculated Metrics by Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_delete_calculated_metric_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The calculated metric ID to be deleted (required)
        :param str locale: Locale
        :return: DeleteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'locale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_delete_calculated_metric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `calculatedmetrics_delete_calculated_metric`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculatedmetrics_get_calculated_metric_function(self, id, **kwargs):  # noqa: E501
        """Retrieve a calculated metric function by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_get_calculated_metric_function(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The function ID to retrieve (required)
        :param str locale: Locale
        :return: CalcMetricFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_get_calculated_metric_function_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_get_calculated_metric_function_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def calculatedmetrics_get_calculated_metric_function_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a calculated metric function by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_get_calculated_metric_function_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The function ID to retrieve (required)
        :param str locale: Locale
        :return: CalcMetricFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'locale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_get_calculated_metric_function" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `calculatedmetrics_get_calculated_metric_function`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/functions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CalcMetricFunction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculatedmetrics_get_calculated_metric_functions(self, **kwargs):  # noqa: E501
        """Retrieve calculated metric functions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_get_calculated_metric_functions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: Locale
        :return: list[CalcMetricFunction]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_get_calculated_metric_functions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_get_calculated_metric_functions_with_http_info(**kwargs)  # noqa: E501
            return data

    def calculatedmetrics_get_calculated_metric_functions_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve calculated metric functions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_get_calculated_metric_functions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: Locale
        :return: list[CalcMetricFunction]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_get_calculated_metric_functions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/functions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalcMetricFunction]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculatedmetrics_update_calculated_metric(self, id, **kwargs):  # noqa: E501
        """Update an existing calculated metric  # noqa: E501

        The following fields can be modified through this endpoint: <br><b>name, description, definition, owner, rsid</b> Example \"defintion\" for use in testing API below (\"Visits per visitor\"):<br> \"definition\": {        \"formula\": {          \"func\": \"divide\",          \"col1\": {            \"func\": \"metric\",            \"name\": \"metrics/visits\",            \"description\": \"Visits\"          },          \"col2\": {            \"func\": \"metric\",            \"name\": \"metrics/visitors\",            \"description\": \"Unique Visitors\"          }        },        \"func\": \"calc-metric\",        \"version\": [          1,          0,          0        ]      }<br><br>Response will be the newly modified calculated metric object after the update request completes.<br><br><b><span style=\"text-decoration: underline;\">CalculatedMetricResponse</span></b><br>A calculated metric response will always include these default items:* id, name, description, rsid, owner*   Other attributes can be optionally requested through the 'expansion' field as defined/documented in the GET endpoints (see GET \"/calculatedmetrics\" or GET \"/calculatedmetrics/{id}\" for more documentation).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_update_calculated_metric(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Calculated Metric ID to be updated (required)
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs to be updated.
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_update_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_update_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def calculatedmetrics_update_calculated_metric_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an existing calculated metric  # noqa: E501

        The following fields can be modified through this endpoint: <br><b>name, description, definition, owner, rsid</b> Example \"defintion\" for use in testing API below (\"Visits per visitor\"):<br> \"definition\": {        \"formula\": {          \"func\": \"divide\",          \"col1\": {            \"func\": \"metric\",            \"name\": \"metrics/visits\",            \"description\": \"Visits\"          },          \"col2\": {            \"func\": \"metric\",            \"name\": \"metrics/visitors\",            \"description\": \"Unique Visitors\"          }        },        \"func\": \"calc-metric\",        \"version\": [          1,          0,          0        ]      }<br><br>Response will be the newly modified calculated metric object after the update request completes.<br><br><b><span style=\"text-decoration: underline;\">CalculatedMetricResponse</span></b><br>A calculated metric response will always include these default items:* id, name, description, rsid, owner*   Other attributes can be optionally requested through the 'expansion' field as defined/documented in the GET endpoints (see GET \"/calculatedmetrics\" or GET \"/calculatedmetrics/{id}\" for more documentation).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_update_calculated_metric_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Calculated Metric ID to be updated (required)
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs to be updated.
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'locale', 'expansion']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_update_calculated_metric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `calculatedmetrics_update_calculated_metric`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'expansion' in params:
            query_params.append(('expansion', params['expansion']))  # noqa: E501
            collection_formats['expansion'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalyticsCalculatedMetric',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculatedmetrics_validate_calculated_metric(self, **kwargs):  # noqa: E501
        """Validate a calculated metric definition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_validate_calculated_metric(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs for calculated metric validation.
        :param str locale: Locale
        :param bool migrating: Include migration functions in validation
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculatedmetrics_validate_calculated_metric_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.calculatedmetrics_validate_calculated_metric_with_http_info(**kwargs)  # noqa: E501
            return data

    def calculatedmetrics_validate_calculated_metric_with_http_info(self, **kwargs):  # noqa: E501
        """Validate a calculated metric definition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculatedmetrics_validate_calculated_metric_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsCalculatedMetric body: JSON-formatted Object containing key/value pairs for calculated metric validation.
        :param str locale: Locale
        :param bool migrating: Include migration functions in validation
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'migrating']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculatedmetrics_validate_calculated_metric" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'migrating' in params:
            query_params.append(('migrating', params['migrating']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalyticsCalculatedMetric',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_calculated_metrics(self, **kwargs):  # noqa: E501
        """Retrieve many calculated metrics  # noqa: E501

        A calculated metric response will always include these default items: *id, name, description, rsid, owner, polarity, precision, type*   Other attributes can be optionally requested through the 'expansion' field:  * *modified*: Date that the metric was last modified (ISO 8601) * *definition*: Calculated metric definition as JSON object * *compatibility*: Products that the metric is compatible with * *reportSuiteName*: Also return the friendly Report Suite name for the RSID * *tags*: Gives all existing tags associated with the calculated metric  For more information about calculated metrics go [here](https://github.com/AdobeDocs/analytics-2.0-apis/blob/master/calculatedmetrics.md)    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_calculated_metrics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rsids: Filter list to only include calculated metrics tied to specified RSID list (comma-delimited)
        :param int owner_id: Filter list to only include calculated metrics owned by the specified loginId
        :param str filter_by_ids: Filter list to only include calculated metrics in the specified list (comma-delimited list of IDs) (this is the same as calculatedMetricFilter, and is overwritten by calculatedMetricFilter
        :param str to_be_used_in_rsid: The report suite where the calculated metric intended to be used.  This report suite will be used to determine things like compatibility and permissions.  If it is not specified then the permissions will be calculated based on the union of all metrics authorized in all groups the user belongs to.  If the compatibility expansion is specified and toBeUsedInRsid is not then the compatibility returned is based off the compatibility from the last time the calculated metric was saved.
        :param str locale: Locale
        :param str name: Filter list to only include calculated metrics that contains the Name
        :param str tag_names: Filter list to only include calculated metrics that contains one of the tags
        :param bool favorite: Filter list to only include calculated metrics that are favorites
        :param bool approved: Filter list to only include calculated metrics that are approved
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :param str sort_direction: Sort direction (ASC or DESC)
        :param str sort_property: Property to sort by (name, modified_date, id is currently allowed)
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :param list[str] include_type: Include additional calculated metrics not owned by user. The \"all\" option takes precedence over \"shared\"
        :return: list[AnalyticsCalculatedMetric]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_calculated_metrics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_calculated_metrics_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_calculated_metrics_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve many calculated metrics  # noqa: E501

        A calculated metric response will always include these default items: *id, name, description, rsid, owner, polarity, precision, type*   Other attributes can be optionally requested through the 'expansion' field:  * *modified*: Date that the metric was last modified (ISO 8601) * *definition*: Calculated metric definition as JSON object * *compatibility*: Products that the metric is compatible with * *reportSuiteName*: Also return the friendly Report Suite name for the RSID * *tags*: Gives all existing tags associated with the calculated metric  For more information about calculated metrics go [here](https://github.com/AdobeDocs/analytics-2.0-apis/blob/master/calculatedmetrics.md)    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_calculated_metrics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rsids: Filter list to only include calculated metrics tied to specified RSID list (comma-delimited)
        :param int owner_id: Filter list to only include calculated metrics owned by the specified loginId
        :param str filter_by_ids: Filter list to only include calculated metrics in the specified list (comma-delimited list of IDs) (this is the same as calculatedMetricFilter, and is overwritten by calculatedMetricFilter
        :param str to_be_used_in_rsid: The report suite where the calculated metric intended to be used.  This report suite will be used to determine things like compatibility and permissions.  If it is not specified then the permissions will be calculated based on the union of all metrics authorized in all groups the user belongs to.  If the compatibility expansion is specified and toBeUsedInRsid is not then the compatibility returned is based off the compatibility from the last time the calculated metric was saved.
        :param str locale: Locale
        :param str name: Filter list to only include calculated metrics that contains the Name
        :param str tag_names: Filter list to only include calculated metrics that contains one of the tags
        :param bool favorite: Filter list to only include calculated metrics that are favorites
        :param bool approved: Filter list to only include calculated metrics that are approved
        :param int limit: Number of results per page
        :param int page: Page number (base 0 - first page is \"0\")
        :param str sort_direction: Sort direction (ASC or DESC)
        :param str sort_property: Property to sort by (name, modified_date, id is currently allowed)
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :param list[str] include_type: Include additional calculated metrics not owned by user. The \"all\" option takes precedence over \"shared\"
        :return: list[AnalyticsCalculatedMetric]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rsids', 'owner_id', 'filter_by_ids', 'to_be_used_in_rsid', 'locale', 'name', 'tag_names', 'favorite', 'approved', 'limit', 'page', 'sort_direction', 'sort_property', 'expansion', 'include_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_calculated_metrics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'rsids' in params:
            query_params.append(('rsids', params['rsids']))  # noqa: E501
        if 'owner_id' in params:
            query_params.append(('ownerId', params['owner_id']))  # noqa: E501
        if 'filter_by_ids' in params:
            query_params.append(('filterByIds', params['filter_by_ids']))  # noqa: E501
        if 'to_be_used_in_rsid' in params:
            query_params.append(('toBeUsedInRsid', params['to_be_used_in_rsid']))  # noqa: E501
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'tag_names' in params:
            query_params.append(('tagNames', params['tag_names']))  # noqa: E501
        if 'favorite' in params:
            query_params.append(('favorite', params['favorite']))  # noqa: E501
        if 'approved' in params:
            query_params.append(('approved', params['approved']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'sort_direction' in params:
            query_params.append(('sortDirection', params['sort_direction']))  # noqa: E501
        if 'sort_property' in params:
            query_params.append(('sortProperty', params['sort_property']))  # noqa: E501
        if 'expansion' in params:
            query_params.append(('expansion', params['expansion']))  # noqa: E501
            collection_formats['expansion'] = 'csv'  # noqa: E501
        if 'include_type' in params:
            query_params.append(('includeType', params['include_type']))  # noqa: E501
            collection_formats['includeType'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnalyticsCalculatedMetric]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_one_calculated_metric(self, id, **kwargs):  # noqa: E501
        """Retrieve a single calculated metric by id  # noqa: E501

        A calculated metric response will always include these default items: *id, name, description, rsid, owner, polarity, precision, type*   Other attributes can be optionally requested through the 'expansion' field:  * *modified*: Date that the metric was last modified (ISO 8601) * *definition*: Calculated metric definition as JSON object * *compatibility*: Products that the metric is compatible with * *reportSuiteName*: Also return the friendly Report Suite name for the RSID * *tags*: Gives all existing tags associated with the calculated metric  For more information about calculated metrics go [here](https://github.com/AdobeDocs/analytics-2.0-apis/blob/master/calculatedmetrics.md)    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_one_calculated_metric(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The calculated metric ID to retrieve (required)
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_one_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_one_calculated_metric_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def find_one_calculated_metric_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a single calculated metric by id  # noqa: E501

        A calculated metric response will always include these default items: *id, name, description, rsid, owner, polarity, precision, type*   Other attributes can be optionally requested through the 'expansion' field:  * *modified*: Date that the metric was last modified (ISO 8601) * *definition*: Calculated metric definition as JSON object * *compatibility*: Products that the metric is compatible with * *reportSuiteName*: Also return the friendly Report Suite name for the RSID * *tags*: Gives all existing tags associated with the calculated metric  For more information about calculated metrics go [here](https://github.com/AdobeDocs/analytics-2.0-apis/blob/master/calculatedmetrics.md)    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_one_calculated_metric_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The calculated metric ID to retrieve (required)
        :param str locale: Locale
        :param list[str] expansion: Comma-delimited list of additional calculated metric metadata fields to include on response.
        :return: AnalyticsCalculatedMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'locale', 'expansion']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_one_calculated_metric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `find_one_calculated_metric`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'expansion' in params:
            query_params.append(('expansion', params['expansion']))  # noqa: E501
            collection_formats['expansion'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/calculatedmetrics/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalyticsCalculatedMetric',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
